<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego: Memoria de Formas</title>
    <link rel="stylesheet" href="../style.css">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #game-container {
            width: 80%;
            max-width: 800px;
            height: 600px;
            cursor: pointer;
        }
        .controls {
            padding: 1rem 0;
        }
    </style>
</head>
<body>
    <h1>Memoria de Formas</h1>
    <div id="game-container"></div>
    <div class="controls">
        <a href="index.html" class="menu-button">Volver a Juegos</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('game-container');
            let scene, camera, renderer, raycaster, mouse;
            let cards = [];
            let firstCard = null, secondCard = null;
            let canFlip = true;
            const cardSize = 2;
            const spacing = 0.5;

            function init() {
                // Scene and Camera
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.z = 10;

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(5, 10, 7.5);
                scene.add(directionalLight);

                // Raycaster
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                // Create Cards
                createCards();

                // Event Listeners
                container.addEventListener('click', onMouseClick);
                window.addEventListener('resize', onWindowResize);

                animate();
            }

            function createCards() {
                const shapes = ['Box', 'Sphere', 'Cone', 'Torus', 'Cylinder', 'Dodecahedron'];
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
                const cardData = [];
                for (let i = 0; i < 6; i++) {
                    cardData.push({ shape: shapes[i], color: colors[i] });
                    cardData.push({ shape: shapes[i], color: colors[i] });
                }
                cardData.sort(() => Math.random() - 0.5);

                const numRows = 3;
                const numCols = 4;
                const totalWidth = numCols * cardSize + (numCols - 1) * spacing;
                const totalHeight = numRows * cardSize + (numRows - 1) * spacing;
                const startX = -totalWidth / 2 + cardSize / 2;
                const startY = totalHeight / 2 - cardSize / 2;

                for (let i = 0; i < cardData.length; i++) {
                    const row = Math.floor(i / numCols);
                    const col = i % numCols;

                    const card = new THREE.Group();
                    card.position.x = startX + col * (cardSize + spacing);
                    card.position.y = startY - row * (cardSize + spacing);

                    const back = new THREE.Mesh(
                        new THREE.BoxGeometry(cardSize, cardSize, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0x3498db })
                    );
                    back.name = 'back';

                    const front = new THREE.Mesh(
                        new THREE.BoxGeometry(cardSize, cardSize, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0xffffff })
                    );
                    front.rotation.y = Math.PI;
                    front.name = 'front';

                    const shapeGeometry = new THREE[cardData[i].shape + 'Geometry'](0.7);
                    const shapeMaterial = new THREE.MeshStandardMaterial({ color: cardData[i].color });
                    const shape = new THREE.Mesh(shapeGeometry, shapeMaterial);
                    shape.position.z = 0.2;
                    shape.rotation.y = Math.PI;
                    front.add(shape);

                    card.add(back);
                    card.add(front);

                    card.userData = { id: i, type: cardData[i].shape, isFlipped: false, isMatched: false };
                    cards.push(card);
                    scene.add(card);
                }
            }

            function onMouseClick(event) {
                if (!canFlip) return;

                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cards.map(c => c.children[0])); // Intersect with card backs

                if (intersects.length > 0) {
                    const clickedCard = intersects[0].object.parent;
                    if (!clickedCard.userData.isFlipped && !clickedCard.userData.isMatched) {
                        flipCard(clickedCard);

                        if (!firstCard) {
                            firstCard = clickedCard;
                        } else {
                            secondCard = clickedCard;
                            canFlip = false;
                            checkForMatch();
                        }
                    }
                }
            }

            function flipCard(card) {
                card.userData.isFlipped = true;
                // Simple flip for now, animation can be added
                card.rotation.y = Math.PI;
            }

            function flipBack(card) {
                card.userData.isFlipped = false;
                card.rotation.y = 0;
            }

            function checkForMatch() {
                if (firstCard.userData.type === secondCard.userData.type) {
                    // Match
                    firstCard.userData.isMatched = true;
                    secondCard.userData.isMatched = true;
                    resetTurn();
                    checkWin();
                } else {
                    // No match
                    setTimeout(() => {
                        flipBack(firstCard);
                        flipBack(secondCard);
                        resetTurn();
                    }, 1000);
                }
            }

            function resetTurn() {
                firstCard = null;
                secondCard = null;
                canFlip = true;
            }

            function checkWin() {
                const allMatched = cards.every(card => card.userData.isMatched);
                if (allMatched) {
                    setTimeout(() => {
                        alert("Â¡Felicidades, has ganado!");
                        // Reset game logic can be added here
                    }, 500);
                }
            }

            function onWindowResize() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }

            init();
        });
    </script>
</body>
</html>