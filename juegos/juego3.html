<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego: Torre de Bloques</title>
    <link rel="stylesheet" href="../style.css">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            margin: 0;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="instructions">Haz clic para soltar un bloque</div>
    <div id="game-container"></div>
    <div class="controls">
        <a href="index.html" class="menu-button">Volver a Juegos</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('game-container');
            let scene, camera, renderer, world;
            let bodies = [];
            let meshes = [];
            let currentBlock;

            function init() {
                // Scene and Camera
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xadd8e6); // Light blue
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 20);
                camera.lookAt(0, 0, 0);

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 15);
                scene.add(directionalLight);

                // Physics World
                world = new CANNON.World();
                world.gravity.set(0, -10, 0);

                // Ground
                const groundShape = new CANNON.Plane();
                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                world.addBody(groundBody);

                const groundMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(100, 100),
                    new THREE.MeshStandardMaterial({ color: 0xcccccc })
                );
                groundMesh.rotation.x = -Math.PI / 2;
                scene.add(groundMesh);

                // Start with a base block
                addBlock(0, 0.5, 0, 4, 1, 4); // A wide base

                // Spawner
                spawnNewBlock();

                // Event Listeners
                container.addEventListener('click', onMouseClick);
                window.addEventListener('resize', onWindowResize);

                animate();
            }

            function addBlock(x, y, z, width, height, depth, isDynamic = true) {
                const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
                const body = new CANNON.Body({
                    mass: isDynamic ? width * height * depth : 0,
                    position: new CANNON.Vec3(x, y, z),
                    shape: shape
                });
                world.addBody(body);
                bodies.push(body);

                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                meshes.push(mesh);
            }

            function spawnNewBlock() {
                const width = Math.random() * 2 + 1;
                const height = Math.random() * 2 + 1;
                const depth = Math.random() * 2 + 1;

                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, transparent: true, opacity: 0.8 });
                currentBlock = new THREE.Mesh(geometry, material);
                currentBlock.position.y = 15;
                currentBlock.userData = {width, height, depth};
                scene.add(currentBlock);
            }

            function onMouseClick() {
                if (currentBlock) {
                    addBlock(
                        currentBlock.position.x,
                        currentBlock.position.y,
                        currentBlock.position.z,
                        currentBlock.userData.width,
                        currentBlock.userData.height,
                        currentBlock.userData.depth
                    );
                    scene.remove(currentBlock);
                    spawnNewBlock();
                }
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                requestAnimationFrame(animate);

                world.step(1/60);

                for (let i = 0; i < bodies.length; i++) {
                    meshes[i].position.copy(bodies[i].position);
                    meshes[i].quaternion.copy(bodies[i].quaternion);
                }

                if (currentBlock) {
                    const time = Date.now() * 0.001;
                    currentBlock.position.x = Math.sin(time) * 5;
                }

                renderer.render(scene, camera);
            }

            init();
        });
    </script>
</body>
</html>